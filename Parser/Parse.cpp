#include "Parse.h"
#include <exception>

std::vector<Rule*> rules;
std::vector<First*> Firsts;
std::vector<Follow*> Follows;
LL1Table* table;

//
// track which token now I current am
//
static int iter = 0;

//
// a map translating Symbol enumerate class to string
//
char symbolToStr[67][20] = {
        // non-terminal symbols
        "program",
        "varDecls",
        "varDecl",
        "declList",
        "declListPostfix",
        "decl",
        "declPostfix",
        "codeBlock",
        "stmts",
        "stmtsPostfix",
        "stmt",
        "controlStmt",
        "rwStmt",
        "assignStmt",
        "assignStmtPostfix",
        "ifStmts",
        "ifStmtsPostfix",
        "ifStmt",
        "whileStmt",
        "dowhileStmt",
        "returnStmt",
        "rStmt",
        "wStmt",
        "exp",
        "realExp",
        "realExpPostfix",
        "OpExp",
        // reversed words
        "INT",
        "MAIN",
        "VOID",
        "BREAK",
        "DO",
        "ELSE",
        "IF",
        "WHILE",
        "RETURN",
        "READ",
        "WRITE",
        // special symbols
        "LBRACE",
        "RBRACE",
        "LSQUARE",
        "RSQUARE",
        "LPAR",
        "RPAR",
        "SEMI",
        "PLUS",
        "MINUS",
        "MUL_OP",
        "DIV_OP",
        "AND_OP",
        "OR_OP",
        "NOT_OP",
        "ASSIGN",
        "LT",
        "GT",
        "SHL_OP",
        "SHR_OP",
        "EQ",
        "NOTEQ",
        "LTEQ",
        "GTEQ",
        "ANDAND",
        "OROR",
        "COMMA",
        // regex symbols
        "INTNUM",
        "ID",
        // null string
        "nullStr",
};

//
// infer the type of a symbol by its literal value
//
Symbol inferType(char* tokenValue) {
    for (int i=0; i<nonTerminalCnt+terminalCnt; i++){
        if (strcmp(tokenValue, symbolToStr[i]) == 0){
            return static_cast<Symbol>(i);
        }
    }
    return Symbol::nullStr;
}

//
// scan tokens from the file generated by the scanner
//
std::vector<Token*> tokenScanner(char* filename){
    std::vector<Token*> res = std::vector<Token*>();

    FILE* fp = nullptr;
    fp = fopen(filename, "r");
    if (fp == nullptr) throw std::runtime_error("No valid file!");
        
    char* semanticBuffer = new char[20];
    char* tokenBuffer = new char[20];
    int N = 99;
    while(fgets(semanticBuffer, N, fp) != nullptr){
        fgets(tokenBuffer, N, fp);
        semanticBuffer[strlen(semanticBuffer)-1] = '\0';
        tokenBuffer[strlen(tokenBuffer)-1] = '\0';
        res.emplace_back(new Token(semanticBuffer, tokenBuffer));
    }
    res.emplace_back(new Token());
    return res;
}

//
// find the matched rule in the LL(1) analysis table
//
inline Rule* matchRule(Symbol crtSymbol, Token* lookahead){
    auto res = table->findProduction(crtSymbol, lookahead->type);
    return res == nullptr ? table->findProduction(crtSymbol, Symbol::nullStr) : res;
}

//
// print the information of the current tree node
//
void printNode(TreeNode* crtNode, int depth){
    // print indention
    for (int i=0; i<depth; i++){
        printf("    ");
    }
    // print symbol type
    printf("--[%s]-(%s)\n", symbolToStr[static_cast<int>(crtNode->mySymbol)], crtNode->semanticValue);
}

Rule* chooseIfRule(std::vector<Token*> tokenVec){
    int tempIter = iter;
    for (int i=tempIter; i<tokenVec.size(); i++){
        if (tokenVec[i]->type == Symbol::IF){
            // if find IF first, then use rule: ifStmtsPostfix->nullStr
            return rules[30];
        } else if (tokenVec[i]->type == Symbol::ELSE){
            // if find ELSE first, then use rule: ifStmtsPostfix->ELSE codeBlock
            return rules[31];
        }
    }
    return rules[30];
}

//
// recursive descent parsing function
//
TreeNode* recursiveParse(Symbol crtSymbol, std::vector<Token*> tokenVec, TreeNode* parentNode){
    auto* crtNode = new TreeNode(crtSymbol, parentNode);
    // base case: if the symbol is a terminal, then return
    if (isTerminal(crtSymbol)) {
        if (crtSymbol != Symbol::nullStr && iter < tokenVec.size()){
            strcpy(crtNode->semanticValue, tokenVec[iter]->semanticValue);
        }
        // when current node is a terminal, advance your iterator to the next token
        if (crtSymbol != Symbol::nullStr) iter++;
        return crtNode;
    }

    auto potentialRules = std::list<Rule*>();
    Rule* appliedRule;
    Token* lookahead;

    // find the correct rule to apply
    if (crtSymbol == Symbol::ifStmtsPostfix){
        appliedRule = chooseIfRule(tokenVec);
    }
    else{
        for (auto rule : rules){
            if (rule->LHS == crtSymbol) potentialRules.emplace_back(rule);
        }
        if (potentialRules.size() > 1){ // we need to find the correct rule using the table
            lookahead = iter < tokenVec.size() ? tokenVec[iter] : new Token(); // get the token
            appliedRule = matchRule(crtSymbol, lookahead);
        } else{
            appliedRule = *potentialRules.begin();
        }
    }

    // check whether we have an applied rule
    if (appliedRule == nullptr){
        throw std::runtime_error("No rule matched!\n");
    }

    // iterate the RHS of the rule and build TreeNode recursively
    for (auto symbol : appliedRule->RHS){
        TreeNode* childNode = recursiveParse(symbol, tokenVec, crtNode);
        childNode->myParent = crtNode;
        crtNode->myChildren.emplace_back(childNode);
    }
    return crtNode;
}

//
// show the whole parse tree
//
void showTree(TreeNode* crtNode, int depth){
    printNode(crtNode, depth);
    for (auto node : crtNode->myChildren) showTree(node, depth+1);
}
